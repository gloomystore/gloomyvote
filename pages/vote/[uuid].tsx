'use client'
import React, { useCallback, useState } from "react";
import Head from 'next/head'
import { GetServerSideProps, GetServerSidePropsContext } from "next";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";

import styles from '@/styles/vote.module.scss'

import NavBar from '@/components/NavBar'
import Footer from '@/components/Footer'

type vote = {
  content: string,
  destroy: string,
  idx: number
  parentid: string,
  uuid: string,
  voteindex: string,
}

export const getServerSideProps: GetServerSideProps<{ uuid: (string | null) }> = async (ctx:GetServerSidePropsContext) => {
  try {
    const { uuid } = ctx.query;
    return {
      props : {
        uuid: uuid as string
      }
    }
  } catch (err:any) {
    console.log(err.message)
  }
  return {
    props : {
      uuid: null
    }
  };
};
const Todos = ({uuid}:{uuid:string}) => {
  console.log(uuid)
  const fetchTodoList = useCallback(async() => {
    try {
      const response = await axios(`/api/vote/voterooms/get/${uuid}`);
      if (!response.data) {
        throw new Error("Failed to fetch todos");
      }
      return response.data;
    } catch (error:any) {
      throw new Error(error.message);
    }
  },[uuid]) 
  const fetchVote = useQuery([uuid], fetchTodoList, {
    refetchOnWindowFocus: false, // react-query는 사용자가 사용하는 윈도우가 다른 곳을 갔다가 다시 화면으로 돌아오면 이 함수를 재실행함. true or false
    retry: 0, // 실패시 재호출 몇번 할지
    onSuccess: data => {
      // 성공시 호출
      console.log(data);
    },
    onError: (e:Error) => {
      // 실패시 호출 (401, 404 같은 error가 아니라 정말 api 호출이 실패한 경우만 호출)
      // 강제로 에러 발생시키려면 api단에서 throw Error 날리면됨 (참조: https://react-query.tanstack.com/guides/query-functions#usage-with-fetch-and-other-clients-that-do-not-throw-by-default)
      console.log(e.message);
    }
  });
  const fetchVoteData = fetchVote.data
  const fetchVoteIsLoading = fetchVote.isLoading
  const fetchVoteIsError = fetchVote.isError
  const fetchVoteError = fetchVote.error

  if (fetchVoteIsLoading) {
    return <span>Loading...</span>;
  }

  else if (fetchVoteIsError) {
    return <span>Error: {fetchVoteError?.message}</span>;
  }

  return (
    <>
      <Head>
        <title>Gloomy Chat</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <NavBar />
      <div className="wrap pt-100">
        {
          fetchVoteData ? 
          <section className="section fadeInUp active blink mt-100 pb-10">
          <h2 className="title-03 mt-0" id="intro">투표번호는 {uuid} 입니다.
          <br /><span className='t-16 t-light'>(기록해주세요)</span>
          </h2>
          <div className={`mt-50 ${styles['vote-room']}`}>
            <article className={`form-underlined dark`}>
              <h3 className='mt-10'><input type="text" placeholder={fetchVoteData.vote.title} readOnly /></h3>
              <div className='mt-30'>
                {
                  fetchVoteData.votemenu.map((vote:vote, idx:number) =>
                  <p key={idx}>
                    <label htmlFor={'vote'+idx}>
                      <input type="radio" name='vote' id={'vote'+idx} />
                      <span>{vote.content}</span>
                    </label>
                  </p>
                  )
                }
              </div>
              <div className='mt-30'>
              <p>
                <input type="number" placeholder={'투표기간: '+fetchVoteData.vote.expire.split('T')[0]} min={1} max={7} className="w-100" readOnly />
              </p>
              </div>
              <div className='mt-30'>
                <button >투표하기</button>
              </div>
              <div className='mt-30'>
                <button>삭제하기</button>
              </div>
            </article>
          </div>
        </section>
          :
              <>
              
              </>

        }
       
      </div>
      <Footer />
    </>
  );
};
export default Todos